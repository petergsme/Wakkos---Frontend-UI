<!-- 
CLASE A LA QUE FALTÉ.

"Siempre que utiliceis un selector descendiente preguntaos por qué lo estais usando, eso os obligará a no usarlo a la ligera"

div *         Selector de Descendiente Universal, selecciona todo lo que haya dentro de divs. 

La parte interesante, hay PSEUDO-CLASES Y PSEUDO-ELEMENTOS.
Las pseudo-clases son clases basadas en la posicion o estado de los elementos respecto al html.

x:first-child  
x:last-child(2)            :nth-of-type(even)
x:only-child               :nth-of-type(An+B)
x:nth-child(3)
x:not(:first-child)        x:empty               

Cuidado, los child se aplican no al padre si no al tipo del elemento del hijo que quieres. Si un div tiene tres p, y quieres acceder al primero escribes p:first-child, el primer hijo p de algo. No escribes div:first-child. Además algunos selectores como last-child puede hacer uso del parentesis para seleccionar posición si usas nth-last-child.

:nth-of-type(2n+3)          Select every 2nd plate, starting from the 3rd, 
                            2n referencia cada cuanto selecciona, el 3 es para desde donde empieza.

apple:only-of-type          Solo selecciona el elemento si es el único de ese tipo en su contenedor.
div:last-of-type            selects the last div in every element.

bento:empty                 Selecciona los bento que no contienen nada más.

.toggle:checked             Elementos activados como una checkbox. Sirve para inputs y options.


Otra parte chula: LOS SELECTORES DE ATRIBUTO.

[attribute]
input[attribute]

[attribute*="value"]       contiene X.
[attribute^="value"]       comienza por X.
[attribute$="value"]       termina con X.

https://flukeout.github.io/

FORMULARIOS:

Un INPUT debe TENER un LABEL cuyo atributo FOR coincida con el ID del INPUT.

<label for="name">Nombre</label>
<input type="text" id="name" placeholder="Jane Doe" disabled>
 
El atributo DISABLED solo puede ser true o false, y marca si una interacción está activa o deshabilitada. Podrías escribir disabled = "true", pero el mero hecho de que aparezca ya implicaría que es true, y cuando no está presente es false.

*Recuerda como funciona el EMMET CHEAT SHEET: nav>ul>1i>a[href="#"]{TExto $} - es igual a acceder a esos atributos en CSS. 

Los links internos, esos que llevan a alguna parte de la página en la que ya estás, se llaman BOOKMARKS. Puedes utilizar atributos ID para nombrar los elementos a los que querrás ir, y elementos A con href con esos ID para llevarte allí.


p:after
p:before

Se trata de pseudoelementos, no son un elemento auténtico, desaparecen si su propiedad content = ""; es eliminada. Recuerda que pueden encadenarse a la: "div:hover:after".

transition: all 0.5s ease-in-out;     Propiedad + tiempo + tipo de transición.

*Puedes animar el movimiento de tus elementos a través de propiedades como top, right, bottom y left O la propiedad transform pero la manera de hacerlo será ligeramente diferente. Translate mueve el elemento con respecto a su propio bloque. top, right, bottom y left mueven un elemento con posicion absolute, con respecto al padre relative más cercano.

transform: translateX(100%);

*Para entrar a ubicar un elemento en el z-index, debe estar posicionado es decir, haber recibido un parámetro de posición distinto al que tiene por defecto, como por ejemplo RELATIVE.


FLEXBOX

Flexbox es la madre del cordero. Perfecto para crear rejillas/cuadrículas y alinear elementos al gusto de cada usuario. Permite posicionar los elementos por medio de filas o columnas, establecer tamaños máximos y mínimos para crear un crecimiento responsive, espaciar los elementos de diferentes maneras y hacerlos fluir a líneas inferiores, obligarles a ocupar el total del ancho o largo de su contenedor...


Flex se aplica y funciona sobre hijos cuyos padres sean display: flex;
Los padres con display: flex; optan a personalizar las siguientes propiedades del elemento:

display: flex;                                                          define el contenedor como un flexbox;

flex-direction: row | row-reverse | column | column-reverse;            establece la dirección del flex: ¿columnas o filas?

flex-wrap: nowrap | wrap | wrap-reverse;                                en flex los elementos intentarán ocupar una línea
                                                                        con wrap puedes hacerlos saltar de línea cuando no quepan.

flex-flow: column wrap;                                                 shorthand de direction y wrap.

justify-content:                                                        disposición de los elementos en el eje horizontal, para línea.
flex-start | flex-end | center | space-between | space-around | space-evenly |
start | end | left | right ... + safe | unsafe;

align-items:                                                            disposición de los elementos en el eje vertical, para línea.
stretch | flex-start | flex-end | center | baseline |
first baseline | last baseline | start | end | self-start | self-end + ... safe | unsafe;

align-content:                                                          como justify-content, pero vertical entre las diferentes LÍNEAS.
flex-start | flex-end | center | space-between | space-around | space-evenly | stretch |
start | end | baseline | first baseline | last baseline + ... safe | unsafe;

*Nota: los align y justify se invierten en su uso para columnas, align hara trabajo horizontal, y justify vertical.
Align-content solo funciona cuando hay varias lineas/columnas.

gap: 10px 20px;                                                         espacio entre elementos de una línea/columna.
/* SHORTHAND: (row-gap-espacio entre las lineas) (column gap- entre las columnas) */

*Sobre GAP: "The behavior could be thought of as a minimum gutter, as if the gutter is bigger somehow (because of something like justify-content: space-between;) then the gap will only take effect if that space would end up smaller."


HIJOS DE UN FLEX:

order: 5; /* default is 0 */                        Permite cambiar el orden de un elemento. Por defecto, toma su posición del HTML.

flex-grow:
1;            El elemento crece en proporción a los demás elementos.
2;            El elemento crecerá hasta ser dos veces mayor que los elementos con flex-grow: 1;
0;            Su valor por defecto, el elemento no crecerá.

flex-shrink:
1;            Su valor por defecto, todos los elementos se encogen igual.
2;            Este elemento se encogerá el doble que los demás.
0;            Este elemento no se encogerá.

*Los valores de ambos son relativos al resto de items flexibles del contenedor.


flex-basis:                                         Define el tamaño base de un elemento antes de que flex-grow o flex-shrink actúen.
auto;        Usa width si está definido, si no, se ajusta al contenido.
content;     Ignora width y se ajusta solo al contenido (soporte limitado)
0px;         Ignora el contenido, depende de flex-grow.
50px;        Inicia con 50px antes de aplicar flex-grow/shrink
10%;         Ocupa el 10% del contenedor antes de crecer o encogerse

min-content; Se ajusta al contenido más pequeño posible sin romperlo
max-content; Se ajusta al contenido más grande sin wrappear.
fit-content; Crece hasta el contenido sin superar el espacio disponible.


flex:                                               Shorthand de grow, shrink y basis en ese orden.

*Cuidado con este shorthand, por defecto es: 0 1 auto; pero al momento que les das algún valor sin especificar, el basis se pone en 0% en vez de auto. Esto hace que no tenga en cuenta el espacio alrededor del contenido.


align-self: auto | flex-start | flex-end...         Es align-items para un único elemento díscolo.

Es buena idea crear clases para hacer grids de diferentes tamaños y contenedores flex:

Cuando quieras desactivar el flex, puedes quitarselo al padre. Dentro de un media query.


MEDIA QUERIES / EM y REM

Usar los EM en Media Queries tiene sentido. El padre de un media query es el body.

1 EM son 16 pixeles. (Porque ese es el tamaño del texto base que se hereda de los estilos por defecto del navegador).
64 EM son 1024px.

El em depende del tamaño del texto del ancestro definido mas cercano. El root del html.

Buena manera de usar los em es hacer que las cosas dependan de EM, y luego tocar tamaños de fuentes de padres.  



-->
